---
title: 排序算法
cover: https://img.yublog.top/img/202211041745573.jpg
top_img: https://img.yublog.top/img/202211041745573.jpg
mathjax: true
---

# 一、排序算法的介绍
1. 排序也称排序算法（SortingAlgorithm），排序是将一组数据，依照指定的顺序进行排列的过程。
# 二、排序算法的分类
## 2.1 内部排序：
指将需要处理的所有数据都加载到内存存储器中进行排序
## 2.2 外部排序
数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
## 2.3 常见的排序算法
![](https://img.yublog.top/img/202211130855165.png)

# 三、算法的时间复杂度
## 3.1 度量程序执行时间的两种方法
1. 事后统计的方法
存在两个问题
	- 想要评测，需要实际允许该程序
	- 所得时间统计，依赖计算机硬件、软件等环境
因此这种方式需要在相同状态下的同一台计算机下运行，才能比较哪个算法速度更快。
2. 事前估计的方法
分析算法的时间复杂度来判断

## 3.2 时间频度
一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法执行次数多，花费时间就长。**一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)**
```java
// T(n) = n+1
int total = 0;
int end = 100;
for(int i = 1; i <= end; i++){
	total += 1;	
}
```
```java
// T(n) = n
int total = 0;
int end = 100;
total = (1 + end) * end / 2;
```

## 3.3 可以忽略哪些
1. 忽略常数项
2. 忽略低次项
3. 忽略系数

## 3.4 时间复杂度
1. 一般情况下、算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(f)的极限为不等于0的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(fn)，称O(fn)为算法的渐进渐进时间复杂度，简称时间复杂度。
2. T(n)不同，但是时间复杂度可能相同。
3. 计算时间复杂度的方法
	- 用常数1代替运行时间中的所有加法常数
	- 修改后的运行次数函数中，只保留高阶项
	- 去除最高阶的系数

# 四、常见的时间复杂度
1. 常数阶 $ O(1) $ 没有循环等复杂结构
2. 对数阶 $ O({log}_{2}n) $ while循环结构
3. 线性阶 $ O(n) $ 一个for循环结构
4. 线性对数阶 $ O(n{log}_{2}n) $ for结构中嵌套while结构
5. 平方阶 $ O({n}^{2}) $ 两个for循环结构嵌套
6. 立方阶 $ O({n}^{3}) $ 三个for循环结构嵌套
7. K次方阶乘 $ O({n}^{k}) $ K个for循环结构嵌套
8. 指数阶 $ O({2}^{n}) $
![](https://img.yublog.top/img/202211131141236.png)

# 五、平均时间复杂度和最坏时间复杂度
1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法运行的时间
2. 最坏时间复杂度是在最坏情况下所有的时间

![](https://img.yublog.top/img/202211131150668.png)
	
# 六、空间复杂度
1. 空间复杂度是所消耗的空间
2. 算法分析主要以时间为主，可以牺牲空间的情况下，提高减少所消耗的时间

# 七、八大排序算法
1. <a href="/Data-structures-and-algorithms/bubbleSort">冒泡排序（BubbleSort）</a>
2. <a href="/Data-structures-and-algorithms/selectSort">选择排序（SelectSort）</a>
3. <a href="/Data-structures-and-algorithms/insertSort">插入排序（InsertSort）</a>